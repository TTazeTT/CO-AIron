<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CO-AIron - Environmental Monitor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Firebase Apps -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <!-- Firebase Realtime Database -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <!-- Firebase Auth (for anonymous sign-in to use Storage) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <!-- Firebase Storage -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --primary-color: #4CAF50;
            --secondary-color: #03A9F4;
            --warning-color: #FFC107;
            --danger-color: #F44336;
            --border-color: #333;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 24px;
        }

        .container {
            max-width: 1200px;
            margin: auto;
        }

        header {
            text-align: center;
            margin-bottom: 32px;
        }

        h1 {
            font-family: 'Pacifico', cursive;
            color: var(--primary-color);
            font-size: 3.5rem;
            margin-bottom: 8px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            padding: 24px;
            background-color: var(--card-bg);
            border-radius: 8px;
            margin-bottom: 32px;
            border: 1px solid var(--border-color);
        }

        .control-group {
            flex: 1;
            min-width: 250px;
        }

        .control-group h3 {
            margin-top: 0;
            color: var(--secondary-color);
        }

        .form-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            align-items: center;
        }

        label {
            font-weight: bold;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 8px;
            background-color: #333;
            border: 1px solid #555;
            color: var(--text-color);
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: #45a049;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #0288d1;
        }

        #user-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 24px;
        }

        .user-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .user-card.status-normal { border-left: 5px solid var(--primary-color); }
        .user-card.status-warning { border-left: 5px solid var(--warning-color); background-color: #433613; }
        .user-card.status-danger { border-left: 5px solid var(--danger-color); background-color: #441c1c; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .user-name {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .device-id {
            font-size: 0.8rem;
            color: #aaa;
        }

        .sensor-data {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 20px;
            text-align: center;
        }

        .sensor-reading .value {
            font-size: 2rem;
            font-weight: bold;
        }
        .sensor-reading .label {
            font-size: 0.9rem;
            color: #bbb;
        }
        .co .value { color: var(--primary-color); }
        .temp .value { color: var(--secondary-color); }
        .humidity .value { color: #8c6eff; }

        .user-card.status-warning .co .value { color: var(--warning-color); }
        .user-card.status-danger .co .value { color: var(--danger-color); }

        .chart-container {
            margin-bottom: 20px;
        }
        .chart-title {
            font-weight: bold;
            margin: 8px 0;
            color: var(--secondary-color);
            font-size: 0.95rem;
        }

        .card-actions {
            display: flex;
            gap: 12px;
        }
        .benchmark-panel {
            display: none;
            margin-top: 12px;
            padding: 12px;
            background-color: #151515;
            border: 1px dashed var(--border-color);
            border-radius: 6px;
        }
        .benchmark-panel.active { display: block; }
        .benchmark-controls {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }
        .benchmark-results {
            margin-top: 8px;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .benchmarks {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        .prediction-display {
            text-align: center;
            margin-bottom: 16px;
        }
        .prediction-display span[data-value="prediction_text"] {
            font-weight: bold;
            color: var(--warning-color);
        }
        .prediction-info {
            font-size: 0.8rem;
            color: #aaa;
        }
        .no-prediction {
            color: #888;
            font-style: italic;
        }
        .backups {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        .backups-list {
            list-style: none;
            padding-left: 0;
            margin: 8px 0 0 0;
        }
        .backups-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px dashed #333;
            font-size: 0.9rem;
        }
        .backups-list li a {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .backups-list li a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>CO-AIron</h1>
            <p>Real-time Air Quality Monitoring</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <h3><i class="icon"></i> Add New User</h3>
                <div class="form-grid">
                    <label for="new-user-name">Name:</label>
                    <input type="text" id="new-user-name" placeholder="e.g., John Doe">
                    <label for="new-device-id">Device ID:</label>
                    <input type="text" id="new-device-id" placeholder="e.g., ESP32-A1B2">
                    <div></div>
                    <button type="button" id="add-user-btn" class="btn-primary">Add User</button>
                </div>
            </div>
            <div class="control-group">
                <h3><i class="icon"></i> CO Alert Thresholds</h3>
                <div class="form-grid">
                    <label for="warning-threshold">Warning (PPM):</label>
                    <input type="number" id="warning-threshold" value="25">
                    <label for="danger-threshold">Danger (PPM):</label>
                    <input type="number" id="danger-threshold" value="50">
                    <div></div>
                    <button type="button" id="update-thresholds-btn" class="btn-secondary">Update</button>
                </div>
            </div>
        </div>

        <main id="user-dashboard"></main>
    </div>

    <script>
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAh3JSDTiKaae5He8InAlgxSTvOKv6MBdc",
            authDomain: "esp32-weldwell-01.firebaseapp.com",
            databaseURL: "https://esp32-weldwell-01-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "esp32-weldwell-01",
            storageBucket: "esp32-weldwell-01.firebasestorage.app",
            messagingSenderId: "147995342502",
            appId: "1:147995342502:web:8d33fddc8e2fad341be667"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        // Sign in anonymously for Storage access if rules require auth
        if (firebase.auth) {
            firebase.auth().signInAnonymously().catch((e) => console.warn('Anon auth failed:', e));
        }

        document.addEventListener('DOMContentLoaded', () => {
            const userDashboard = document.getElementById('user-dashboard');
            const addUserBtn = document.getElementById('add-user-btn');
            const newUserNameInput = document.getElementById('new-user-name');
            const newDeviceIdInput = document.getElementById('new-device-id');
            const updateThresholdsBtn = document.getElementById('update-thresholds-btn');
            const warningThresholdInput = document.getElementById('warning-threshold');
            const dangerThresholdInput = document.getElementById('danger-threshold');

            let users = {};
            let charts = {};
            let predCharts = {};
            let ignoredDevices = new Set();
            let backupRefs = {};
            let alertThresholds = {
                warning: 25,
                danger: 50
            };

            const MAX_DATA_POINTS = 30;

            // --- User Management ---
            
            function addUser(name, deviceId) {
                if (!name || !deviceId) {
                    alert('Please provide both a name and a device ID.');
                    return;
                }
                if (users[deviceId]) {
                    alert('A user with this Device ID already exists.');
                    return;
                }

                // Simple deviceId validation: no whitespace and reasonable length
                const deviceIdPattern = /^[A-Za-z0-9_-]{3,40}$/;
                if (!deviceIdPattern.test(deviceId)) {
                    alert('Device ID must be 3-40 characters and only contain letters, numbers, hyphens and underscores.');
                    return;
                }

                const newUser = {
                    id: 'user-' + Date.now(),
                    name,
                    deviceId,
                    history: [],
                    currentData: { co: 0, temp: 0, humidity: 0, timestamp: Date.now() }
                };
                
                try {
                    console.log('Adding user locally', newUser);
                    // Optimistically add and render the user
                    users[deviceId] = newUser;
                    renderUserCard(newUser);
                } catch (e) {
                    alert('An error occurred while adding the user card. Please check the console for details.');
                    console.error(e);
                    // remove the user from the local cache if rendering fails
                    delete users[deviceId]; 
                    return; // stop execution
                }

                // Add user to Firebase and handle errors (rollback optimistic UI on failure)
                database.ref('users/' + deviceId).set({
                    name: name,
                    deviceId: deviceId
                }).then(() => {
                    console.log('User saved to Firebase:', deviceId);
                }).catch((err) => {
                    console.error('Failed to save user to Firebase:', err);
                    alert('Failed to save user to Firebase. Check console for details.');
                    // rollback local change
                    delete users[deviceId];
                    const el = document.getElementById(newUser.id);
                    if (el && el.parentNode) el.parentNode.removeChild(el);
                });

                newUserNameInput.value = '';
                newDeviceIdInput.value = '';
            }

            function renameUser(deviceId) {
                const user = users[deviceId];
                if (!user) return;

                const newName = prompt(`Enter new name for ${user.name}:`, user.name);
                if (newName && newName.trim() !== '') {
                    user.name = newName.trim();
                    document.querySelector(`#${user.id} .user-name`).textContent = user.name;
                    // Update user name in Firebase
                    database.ref('users/' + deviceId).update({
                        name: newName.trim()
                    });
                }
            }

            function deleteUser(deviceId) {
                const user = users[deviceId];
                if (!user) return;
                if (!confirm(`Delete user '${user.name}' (Device ID: ${deviceId})? This removes the user card and will prevent automatic re-creation until new data or manual removal of the ignore flag.`)) {
                    return;
                }

                // Remove local UI and state
                const el = document.getElementById(user.id);
                if (el && el.parentNode) el.parentNode.removeChild(el);
                delete users[deviceId];
                if (charts[deviceId]) {
                    try { charts[deviceId].destroy(); } catch (e) {}
                    delete charts[deviceId];
                }
                if (predCharts[deviceId]) {
                    try { predCharts[deviceId].destroy(); } catch (e) {}
                    delete predCharts[deviceId];
                }
                if (backupRefs[deviceId]) {
                    try { backupRefs[deviceId].off(); } catch (e) {}
                    delete backupRefs[deviceId];
                }

                // Add to ignored list so incoming data won't auto-create the card
                ignoredDevices.add(deviceId);

                // Remove from Firebase users list (best-effort)
                database.ref('users/' + deviceId).remove().then(() => {
                    console.log('User entry removed from Firebase:', deviceId);
                }).catch((err) => {
                    console.warn('Failed to remove user from Firebase:', err);
                });
            }

            // --- Data Handling ---
            function getStatus(coLevel) {
                if (coLevel >= alertThresholds.danger) return 'danger';
                if (coLevel >= alertThresholds.warning) return 'warning';
                return 'normal';
            }

            function exportToCSV(deviceId) {
                const user = users[deviceId];
                if (!user || user.history.length === 0) {
                    alert('No data to export.');
                    return;
                }

                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "Timestamp (Date and Time),CO Raw Data,Temp Raw Data,Humidity Raw Data\n";

                user.history.forEach(record => {
                    // Prefer client timestamp if present; fallback to server timestamp
                    const ts = record.client_timestamp || record.timestamp || '';
                    const tsStr = ts ? new Date(ts).toISOString() : '';
                    const row = [tsStr, record.co, record.temp, record.humidity].join(",");
                    csvContent += row + "\n";
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", `${user.deviceId}_history.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // --- Rendering ---
            function renderUserCard(user) {
                const card = document.createElement('div');
                card.className = 'user-card status-normal';
                card.id = user.id;

                card.innerHTML = `
                    <div class="card-header">
                        <div>
                            <div class="user-name">${user.name}</div>
                            <div class="device-id">ID: ${user.deviceId}</div>
                        </div>
                    </div>
                    <div class="sensor-data">
                        <div class="sensor-reading co">
                            <div class="value" data-value="co">0.00</div>
                            <div class="label">CO (PPM)</div>
                        </div>
                        <div class="sensor-reading temp">
                            <div class="value" data-value="temp">0.0</div>
                            <div class="label">Temp (°C)</div>
                        </div>
                        <div class="sensor-reading humidity">
                            <div class="value" data-value="humidity">0</div>
                            <div class="label">Humidity (%)</div>
                        </div>
                    </div>
                    <div class="prediction-display">
                        Prediction: <span data-value="prediction_text">N/A</span>
                        <div class="prediction-info">Short-term prediction (next step)</div>
                        <div class="prediction-info">Client time: <span data-value="client_timestamp">—</span></div>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">CO (PPM) - Raw Readings</div>
                        <canvas id="chart-${user.id}"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">Predicted CO</div>
                        <canvas id="chart-pred-${user.id}"></canvas>
                    </div>
                    <div class="card-actions">
                        <button class="btn-secondary rename-btn">Rename</button>
                        <button class="btn-primary export-btn">Export CSV</button>
                        <button class="btn-secondary delete-btn">Delete</button>
                        <button class="btn-secondary benchmark-toggle-btn" title="Toggle Benchmark">Benchmark</button>
                    </div>
                    <div class="benchmark-panel" id="benchmark-${user.id}">
                        <div class="benchmark-controls">
                            <div>
                                <div class="chart-title">Benchmark Options</div>
                                <label><input type="checkbox" class="bm-hz" value="5" checked> 5 min</label>
                                <label style="margin-left:8px;"><input type="checkbox" class="bm-hz" value="30" checked> 30 min</label>
                                <label style="margin-left:8px;"><input type="checkbox" class="bm-hz" value="60" checked> 1 hour</label>
                                <div style="margin-top:6px; font-size:0.85rem; color:#aaa;">Dataset: Latest backup CSV</div>
                            </div>
                            <div>
                                <button class="btn-primary run-benchmark-btn">Run Benchmark</button>
                            </div>
                        </div>
                        <div class="benchmark-results" id="benchmark-results-${user.id}">Toggle to run a benchmark on the latest backup.</div>
                    </div>
                    <div class="backups">
                        <div class="chart-title">Backups</div>
                        <ul id="backups-${user.id}" class="backups-list"></ul>
                    </div>
                    <div class="benchmarks">
                        <div class="chart-title">Benchmarks</div>
                        <ul id="benchmarks-${user.id}" class="backups-list"></ul>
                    </div>
                `;

                userDashboard.appendChild(card);
                
                card.querySelector('.rename-btn').addEventListener('click', () => renameUser(user.deviceId));
                card.querySelector('.export-btn').addEventListener('click', () => exportToCSV(user.deviceId));
                card.querySelector('.delete-btn').addEventListener('click', () => deleteUser(user.deviceId));
                card.querySelector('.benchmark-toggle-btn').addEventListener('click', () => toggleBenchmarkPanel(user.deviceId));
                card.querySelector('.run-benchmark-btn').addEventListener('click', () => runBenchmark(user.deviceId));

                createChart(user);
                createPredictionChart(user);
                observeBackups(user);
                observeBenchmarks(user);
            }

            function updateUserCard(user) {
                const card = document.getElementById(user.id);
                if (!card) return;

                card.querySelector('[data-value="co"]').textContent = user.currentData.co.toFixed(2);
                card.querySelector('[data-value="temp"]').textContent = user.currentData.temp.toFixed(1);
                card.querySelector('[data-value="humidity"]').textContent = Math.round(user.currentData.humidity);

                const predictionText = card.querySelector('[data-value="prediction_text"]');
                if (user.currentData && user.currentData.prediction !== undefined && user.currentData.prediction !== null) {
                    predictionText.textContent = user.currentData.prediction.toFixed(2) + " PPM";
                    predictionText.classList.remove('no-prediction');
                } else {
                    predictionText.textContent = "No prediction available";
                    predictionText.classList.add('no-prediction');
                }

                const clientTsEl = card.querySelector('[data-value="client_timestamp"]');
                if (user.currentData && user.currentData.client_timestamp) {
                    try {
                        clientTsEl.textContent = new Date(user.currentData.client_timestamp).toLocaleString();
                    } catch (e) { clientTsEl.textContent = user.currentData.client_timestamp; }
                } else {
                    clientTsEl.textContent = '—';
                }

                const status = getStatus(user.currentData.co);
                card.className = `user-card status-${status}`;
            }

            // --- Charting ---
            function createChart(user) {
                const ctx = document.getElementById(`chart-${user.id}`).getContext('2d');
                charts[user.deviceId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'CO (PPM)',
                            data: [],
                            borderColor: '#4CAF50',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#999' },
                                grid: { color: '#333' }
                            },
                            x: {
                                ticks: { display: false },
                                grid: { display: false }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
            }

            function createPredictionChart(user) {
                const ctx = document.getElementById(`chart-pred-${user.id}`).getContext('2d');
                predCharts[user.deviceId] = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Predicted CO (PPM)',
                            data: [],
                            borderColor: '#03A9F4',
                            backgroundColor: 'rgba(3, 169, 244, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#999' },
                                grid: { color: '#333' }
                            },
                            x: {
                                ticks: { display: false },
                                grid: { display: false }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
            }

            function updateChart(user) {
                const chart = charts[user.deviceId];
                if (!chart) return;

                const labels = user.history.map(d => new Date(d.timestamp).toLocaleTimeString());
                const data = user.history.map(d => d.co);

                chart.data.labels = labels;
                chart.data.datasets[0].data = data;

                const status = getStatus(user.currentData.co);
                let borderColor = '#4CAF50'; // Normal
                if (status === 'warning') borderColor = '#FFC107';
                if (status === 'danger') borderColor = '#F44336';
                chart.data.datasets[0].borderColor = borderColor;
                
                chart.update('none');
            }

            function updatePredictionChart(user) {
                const chart = predCharts[user.deviceId];
                if (!chart) return;

                const labels = user.history.map(d => new Date(d.timestamp).toLocaleTimeString());
                const data = user.history.map(d => (d.prediction !== undefined && d.prediction !== null) ? d.prediction : null);

                chart.data.labels = labels;
                chart.data.datasets[0].data = data;
                chart.update('none');
            }

            function observeBackups(user) {
                const ref = database.ref('backups/' + user.deviceId).limitToLast(10);
                backupRefs[user.deviceId] = ref;
                const el = document.getElementById(`backups-${user.id}`);
                const render = (snapshot) => {
                    if (!el) return;
                    const val = snapshot.val() || {};
                    // val is an object keyed by timestamp ISO -> meta
                    const entries = Object.entries(val)
                        .map(([k, v]) => ({ key: k, meta: v }))
                        .sort((a, b) => (a.key < b.key ? 1 : -1)); // newest first
                    el.innerHTML = entries.map(({ key, meta }) => {
                        const name = meta.name || 'backup.csv';
                        const link = meta.downloadUrl || meta.webContentLink || meta.webViewLink || '#';
                        const when = new Date(meta.createdTime || key).toLocaleString();
                        const size = meta.size ? ` (${meta.size} bytes)` : '';
                        return `<li><span>${name}${size}</span><a href="${link}" target="_blank" rel="noopener">Download</a></li>`;
                    }).join('');
                };
                ref.on('value', render);
            }

            function observeBenchmarks(user) {
                const ref = database.ref('benchmarks/' + user.deviceId).limitToLast(10);
                const el = document.getElementById(`benchmarks-${user.id}`);
                const render = (snapshot) => {
                    if (!el) return;
                    const val = snapshot.val() || {};
                    const entries = Object.entries(val)
                        .map(([k, v]) => ({ key: k, meta: v }))
                        .sort((a, b) => (a.key < b.key ? 1 : -1));
                    el.innerHTML = entries.map(({ key, meta }) => {
                        const name = meta.name || 'benchmark.csv';
                        const link = meta.downloadUrl || '#';
                        const when = new Date(meta.createdTime || key).toLocaleString();
                        const size = meta.size ? ` (${meta.size} bytes)` : '';
                        const summary = meta.summary ? ` — MAE: ${Number(meta.summary.MAE).toFixed(2)}, RMSE: ${Number(meta.summary.RMSE).toFixed(2)}, MAPE: ${Number(meta.summary.MAPE).toFixed(1)}%` : '';
                        return `<li><span>${when} — ${name}${size}${summary}</span><a href="${link}" target="_blank" rel="noopener">Download</a></li>`;
                    }).join('');
                };
                ref.on('value', render);
            }

            // --- Benchmarking ---
            function toggleBenchmarkPanel(deviceId) {
                const user = users[deviceId];
                if (!user) return;
                const panel = document.getElementById(`benchmark-${user.id}`);
                if (!panel) return;
                panel.classList.toggle('active');
            }

            async function runBenchmark(deviceId) {
                try {
                    const user = users[deviceId];
                    if (!user) return;
                    const panel = document.getElementById(`benchmark-${user.id}`);
                    const resultsEl = document.getElementById(`benchmark-results-${user.id}`);
                    if (resultsEl) { resultsEl.textContent = 'Preparing benchmark…'; }

                    // Get selected horizons
                    const hzEls = panel ? panel.querySelectorAll('.bm-hz:checked') : [];
                    const horizonsMin = Array.from(hzEls).map(el => parseInt(el.value, 10));
                    if (horizonsMin.length === 0) horizonsMin.push(5);

                    const csv = await fetchLatestBackupCsv(deviceId);
                    if (!csv) {
                        if (resultsEl) resultsEl.textContent = 'No backup found for this device. Create a backup first.';
                        return;
                    }
                    const rows = parseBackupCsv(csv);
                    if (rows.length < 40) {
                        if (resultsEl) resultsEl.textContent = 'Not enough rows to run benchmark (need at least 40).';
                        return;
                    }

                    // Evaluate walk-forward linear regression
                    const { summary, detailedCsv } = evaluateBenchmark(rows, horizonsMin);
                    if (resultsEl) {
                        resultsEl.innerHTML = `
                            <div><strong>Summary</strong></div>
                            <div>Samples: ${summary.count}</div>
                            <div>MAE: ${summary.MAE.toFixed(2)} PPM</div>
                            <div>RMSE: ${summary.RMSE.toFixed(2)} PPM</div>
                            <div>MAPE: ${summary.MAPE.toFixed(1)}%</div>
                            <div style="margin-top:8px;">Uploading results…</div>
                        `;
                    }

                    const nowIso = new Date().toISOString();
                    const filename = `${deviceId}_${nowIso.replace(/[:]/g, '-')}_benchmark.csv`;
                    const blob = new Blob([detailedCsv], { type: 'text/csv;charset=utf-8' });
                    const { downloadUrl, size } = await uploadBenchmarkCsv(deviceId, filename, blob);

                    // Write metadata with summary
                    await writeBenchmarkMetadata(deviceId, nowIso, {
                        name: filename,
                        size: size,
                        createdTime: nowIso,
                        downloadUrl: downloadUrl,
                        summary: summary
                    });

                    if (resultsEl) {
                        resultsEl.innerHTML += `<div>Done. <a href="${downloadUrl}" target="_blank" rel="noopener">Download CSV</a></div>`;
                    }
                } catch (err) {
                    console.error('Benchmark failed', err);
                    alert('Benchmark failed: ' + (err && err.message ? err.message : err));
                }
            }

            async function fetchLatestBackupCsv(deviceId) {
                // Get latest backup metadata
                const snap = await database.ref('backups/' + deviceId).limitToLast(1).get();
                if (!snap.exists()) return null;
                const obj = snap.val();
                const key = Object.keys(obj).sort((a,b) => (a < b ? 1 : -1))[0];
                const meta = obj[key];
                const url = meta.downloadUrl || meta.webContentLink || meta.webViewLink;
                if (!url) return null;
                const resp = await fetch(url);
                if (!resp.ok) throw new Error('Failed to download CSV: HTTP ' + resp.status);
                return await resp.text();
            }

            function parseBackupCsv(csvText) {
                const lines = csvText.split(/\r?\n/).filter(l => l.trim().length > 0);
                if (lines.length < 2) return [];
                const header = lines[0].split(',').map(s => s.trim());
                const tsIdx = header.findIndex(h => /timestamp/i.test(h));
                let coIdx = header.findIndex(h => /CO\s*Raw/i.test(h));
                if (coIdx === -1) coIdx = header.findIndex(h => /CO/i.test(h));
                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split(',');
                    if (parts.length < 2) continue;
                    const ts = parts[tsIdx] ? Date.parse(parts[tsIdx]) : NaN;
                    const co = parseFloat(parts[coIdx]);
                    if (!isNaN(ts) && !isNaN(co)) {
                        rows.push({ timestamp: ts, co });
                    }
                }
                rows.sort((a,b) => a.timestamp - b.timestamp);
                return rows;
            }

            function linearRegressionCoeffs(points) {
                const n = points.length;
                if (n < 2) return { m: 0, b: points[0] ? points[0].y : 0 };
                let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                for (const p of points) {
                    sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumXX += p.x * p.x;
                }
                const denom = (n * sumXX - sumX * sumX);
                if (denom === 0) return { m: 0, b: sumY / n };
                const m = (n * sumXY - sumX * sumY) / denom;
                const b = (sumY - m * sumX) / n;
                return { m, b };
            }

            function evaluateBenchmark(rows, horizonsMin) {
                const minTrain = 20;
                const results = [];
                const msPerMin = 60 * 1000;
                const xs = rows.map(r => r.timestamp);
                const ys = rows.map(r => r.co);
                for (let i = minTrain; i < rows.length - 1; i++) {
                    const train = [];
                    for (let j = 0; j < i; j++) {
                        train.push({ x: xs[j], y: ys[j] });
                    }
                    const { m, b } = linearRegressionCoeffs(train);
                    for (const hz of horizonsMin) {
                        const targetTs = xs[i] + hz * msPerMin;
                        let k = i + 1;
                        while (k < rows.length && xs[k] < targetTs) k++;
                        if (k >= rows.length) continue;
                        const yTrue = ys[k];
                        const yPred = m * targetTs + b;
                        const err = yPred - yTrue;
                        const absErr = Math.abs(err);
                        const sqErr = err * err;
                        const ape = yTrue !== 0 ? Math.abs(err / yTrue) * 100 : 0;
                        results.push({
                            timestamp: new Date(xs[k]).toISOString(),
                            horizonMin: hz,
                            y_true: yTrue,
                            y_pred: yPred,
                            abs_error: absErr,
                            sq_error: sqErr,
                            ape: ape
                        });
                    }
                }
                const count = results.length;
                const mae = count ? results.reduce((s, r) => s + r.abs_error, 0) / count : 0;
                const rmse = count ? Math.sqrt(results.reduce((s, r) => s + r.sq_error, 0) / count) : 0;
                const mape = count ? (results.reduce((s, r) => s + r.ape, 0) / count) : 0;
                const header = 'timestamp_iso,horizon_min,y_true,y_pred,abs_error,sq_error,ape_percent\n';
                const body = results.map(r => [r.timestamp, r.horizonMin, r.y_true, r.y_pred, r.abs_error, r.sq_error, r.ape].join(',')).join('\n');
                return {
                    summary: { count, MAE: mae, RMSE: rmse, MAPE: mape },
                    detailedCsv: header + body + '\n'
                };
            }

            function resolveStorageRootRef() {
                const projectId = firebase.app().options.projectId;
                return firebase.storage().refFromURL(`gs://${projectId}.appspot.com`);
            }

            async function uploadBenchmarkCsv(deviceId, filename, blob) {
                try { await firebase.auth().signInAnonymously(); } catch (e) { /* ignore */ }
                const rootRef = resolveStorageRootRef();
                const path = `benchmarks/${deviceId}/${filename}`;
                const fileRef = rootRef.child(path);
                const task = await fileRef.put(blob, { contentType: 'text/csv' });
                const downloadUrl = await task.ref.getDownloadURL();
                return { downloadUrl, size: blob.size };
            }

            async function writeBenchmarkMetadata(deviceId, keyIso, meta) {
                await database.ref('benchmarks/' + deviceId + '/' + keyIso).set(meta);
            }

            // --- Event Listeners ---
            
            addUserBtn.addEventListener('click', () => {
                addUser(newUserNameInput.value.trim(), newDeviceIdInput.value.trim());
            });

            updateThresholdsBtn.addEventListener('click', () => {
                const newWarning = parseFloat(warningThresholdInput.value);
                const newDanger = parseFloat(dangerThresholdInput.value);

                if (isNaN(newWarning) || isNaN(newDanger) || newWarning < 0 || newDanger < 0) {
                    alert('Please enter valid, non-negative numbers for thresholds.');
                    return;
                }
                if (newWarning >= newDanger) {
                    alert('Warning threshold must be less than the danger threshold.');
                    return;
                }
                alertThresholds.warning = newWarning;
                alertThresholds.danger = newDanger;
                alert('Thresholds updated!');
            });

            // --- Firebase Listeners ---

            // This function handles new data for a device, updating its card and chart.
            function handleDataUpdate(snapshot) {
                const deviceId = snapshot.key;
                const sensorData = snapshot.val();
                let user = users[deviceId];

                // If the device has been deleted locally, ignore incoming data to avoid re-creating it
                if (typeof ignoredDevices !== 'undefined' && ignoredDevices.has && ignoredDevices.has(deviceId)) {
                    console.log('Ignoring incoming data for deleted device:', deviceId);
                    return;
                }

                // If data arrives for a device we don't know, create it automatically.
                if (!user) {
                    const newUser = {
                        id: 'user-' + Date.now(),
                        name: deviceId, // Default name is the device ID
                        deviceId: deviceId,
                        history: [],
                        currentData: { co: 0, temp: 0, humidity: 0, timestamp: Date.now() }
                    };
                    users[deviceId] = newUser;
                    renderUserCard(newUser);
                    user = newUser; // Assign to user so the rest of the function works

                    // Also add this new user to Firebase so it's persisted
                    database.ref('users/' + deviceId).set({ name: deviceId, deviceId: deviceId });
                }

                // Normalize incoming prediction field names.
                // Mobile app writes both: `prediction` (short-term) and optionally
                // `co_pred_30m` / `co_pred_1h`.
                // To match Android UI, show the short-term `prediction` by default.
                const predictedRaw = (sensorData && sensorData.prediction !== undefined && sensorData.prediction !== null)
                    ? sensorData.prediction
                    : (sensorData && sensorData.co_pred_1h !== undefined && sensorData.co_pred_1h !== null)
                        ? sensorData.co_pred_1h
                        : null;

                // Coerce to number when possible; otherwise use null to indicate no prediction
                let predictedValue = null;
                if (predictedRaw !== null) {
                    const num = Number(predictedRaw);
                    predictedValue = (isNaN(num) ? null : num);
                }

                const newData = {
                    co: sensorData.co,
                    temp: sensorData.temp,
                    humidity: sensorData.humidity,
                    timestamp: sensorData.timestamp,
                    client_timestamp: sensorData.client_timestamp || null,
                    prediction: predictedValue
                };
                user.currentData = newData;
                user.history.push(newData);
                if (user.history.length > MAX_DATA_POINTS) {
                    user.history.shift();
                }
                updateUserCard(user);
                updateChart(user);
                updatePredictionChart(user);
            }

            const usersRef = database.ref('users');
            usersRef.on('child_added', (snapshot) => {
                const deviceId = snapshot.key;
                const userData = snapshot.val();
                if (!users[deviceId]) {
                    const newUser = {
                        id: 'user-' + Date.now(),
                        name: userData.name,
                        deviceId: deviceId,
                        history: [],
                        currentData: { co: 0, temp: 0, humidity: 0, timestamp: Date.now() }
                    };
                    users[deviceId] = newUser;
                    renderUserCard(newUser);

                    // After creating a card, immediately fetch its latest data point.
                    // This makes the card populate with data instantly.
                    database.ref('data/' + deviceId).get().then((dataSnapshot) => {
                        if (dataSnapshot.exists()) {
                            // Re-use our data handling logic by faking a snapshot object
                            handleDataUpdate({ key: deviceId, val: () => dataSnapshot.val() });
                        }
                    });
                }
            });

            const dataRef = database.ref('data');
            // When data is first added OR when it changes, update the dashboard.
            dataRef.on('child_added', handleDataUpdate);
            dataRef.on('child_changed', handleDataUpdate);
        });
    </script>

</body>
</html>
